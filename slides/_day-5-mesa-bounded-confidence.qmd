# Bounded Confidence Models

## Imports

```{python}
from mesa import Agent
from mesa import Model
from mesa.space import MultiGrid
from mesa.time import RandomActivation
from mesa.datacollection import DataCollector
import matplotlib.pyplot as plt
import seaborn as sns
from pprint import pprint
import yaml

import icsspy
icsspy.set_style()
```

## [(BCM)]{.lightgray} The Agent Class 

```{python}
class BCMAgent(Agent):
    def __init__(self, unique_id, model, epsilon, max_agent_step_size=1):
        super().__init__(unique_id, model)
        self.opinion = self.random.uniform(-1, 1)  # Agent's opinion initialized between -1 and 1
        self.epsilon = epsilon  # Confidence bound (Îµ)
        self.max_agent_step_size = max_agent_step_size  # Step size for movement
        self.pos_history = []  # Track agent's position over time
        self.interactions = {}  # Track interactions with a count

    def step(self):
        # Move to a random neighboring cell with the given step size
        possible_moves = self.model.grid.get_neighborhood(self.pos, moore=True, include_center=False, radius=self.max_agent_step_size)
        new_position = self.random.choice(possible_moves)
        self.model.grid.move_agent(self, new_position)
        self.pos_history.append(new_position)  # Record the new position

        # Interact with neighbors within confidence bound
        neighbors = self.model.grid.get_neighbors(self.pos, moore=True, include_center=False)
        for neighbor in neighbors:
            if abs(self.opinion - neighbor.opinion) <= self.epsilon:
                # Update opinion if within confidence bound
                self.opinion = (self.opinion + neighbor.opinion) / 2

            # Record interactions
            if neighbor.unique_id in self.interactions:
                self.interactions[neighbor.unique_id] += 1
            else:
                self.interactions[neighbor.unique_id] = 1

```

## [(BCM)]{.lightgray} The Model Class 

```{python}
class BoundedConfidenceModel(Model):
    def __init__(self, grid_width, grid_height, N, epsilon, max_agent_step_size=1):
        super().__init__()
        self.num_agents = N
        self.grid = MultiGrid(grid_width, grid_height, True)
        self.schedule = RandomActivation(self)
        self.epsilon = epsilon
        self.max_agent_step_size = max_agent_step_size

        # Create agents
        for i in range(self.num_agents):
            step_size = max_agent_step_size if i % 2 == 0 else 1  # Half agents have large step size, half small
            agent = BCMAgent(i, self, epsilon, max_agent_step_size=step_size)
            self.grid.place_agent(agent, (self.random.randrange(self.grid.width),
                                          self.random.randrange(self.grid.height)))
            agent.pos_history.append(agent.pos)  # Initialize the position history with the starting position
            self.schedule.add(agent)

        self.datacollector = DataCollector(
            agent_reporters={"Opinion": "opinion"}
        )

    def step(self):
        self.datacollector.collect(self)
        self.schedule.step()

    def get_interaction_graph(self):
        G = nx.Graph()
        for agent in self.schedule.agents:
            G.add_node(agent.unique_id)
            for interacted_agent, count in agent.interactions.items():
                if G.has_edge(agent.unique_id, interacted_agent):
                    G[agent.unique_id][interacted_agent]['weight'] += count
                else:
                    G.add_edge(agent.unique_id, interacted_agent, weight=count)
        return G

```

## [(BCM)]{.lightgray} Model Parameters

```{python}
with open('_variables.yml', 'r') as file:
    params = yaml.safe_load(file)

model_params = params.get('model_0')
pprint(model_params)
```

# Run the Model & Collect Data

```{python}
model = BoundedConfidenceModel(
    grid_width=model_params['grid_width'],
    grid_height=model_params['grid_height'],
    N=model_params['N'],
    epsilon=model_params['epsilon'],
    max_agent_step_size=model_params['max_agent_step_size'],
)

for i in range(model_params['n_iterations']):
    model.step()

results = model.datacollector.get_agent_vars_dataframe().reset_index()
results.head(10)
```

## Plot Opinion Distributions

```{python}
grouped = results.groupby('Step')

plt.figure(figsize=(10, 6))  

for name, group in grouped:
    sns.kdeplot(group['Opinion'], color='C0', alpha=0.2) # clip=(-1,1) 

plt.xlabel('\nOpinion')
plt.ylabel('Density\n')
plt.title(f'Opinion Distribution Through Time\nEpsilon {model_params['epsilon']}\n', loc='left')
plt.grid(True)
plt.savefig('media/bounded-confidence-opinion-distribution-evolution.png', dpi=300)
```


Alternatively, a step density histogram

```{python}
grouped = results.groupby('Step')

import matplotlib.pyplot as plt
import numpy as np

plt.figure(figsize=(10, 6))

# Define bins
bins = np.linspace(-1, 1, 21)  # 20 bins between -1 and 1

# Iterate over each group and plot a step histogram
for name, group in grouped:
    plt.hist(group['Opinion'], bins=bins, density=True, histtype='step', color='C0', alpha=0.5, linewidth=2)

plt.xlim(-1, 1)
plt.xlabel('Opinion')
plt.ylabel('Density')
plt.title(f'Opinion Distribution Through Time\nEpsilon {model_params['epsilon']}\n', loc='left')
plt.show()
```

## Scatterplot

```{python}
import matplotlib.pyplot as plt
import numpy as np

time_steps = results['Step']
opinions = results['Opinion']
title = "Bounded Confidence Model\n" + r"$\epsilon$" + f" = {model_params['epsilon']}\n"

plt.figure(figsize=(12, 6))
sc = plt.scatter(time_steps, opinions, c=opinions, cmap='coolwarm', alpha=0.5, s=10)
cbar = plt.colorbar(sc)
cbar.set_label('Opinion')
plt.xlabel('Time (Steps)')
plt.ylabel('Opinion')
plt.title(title, loc='left')
plt.xlim(time_steps.min(), time_steps.max())
plt.ylim(-1.01, 1) 
plt.savefig(f'media/bpunded_confidence_epsilon_{model_params['epsilon']}_one_run.png', dpi=300)
```

## Batch Runs

```{python}
def run_batch_simulation(model_params, n_runs):
    all_results = []

    for run_id in range(n_runs):
        model = BoundedConfidenceModel(
            grid_width=model_params['grid_width'],
            grid_height=model_params['grid_height'],
            N=model_params['N'],
            epsilon=model_params['epsilon'],
            max_agent_step_size=model_params['max_agent_step_size'],
        )
        
        for i in range(model_params['n_iterations']):
            model.step()

        run_results = model.datacollector.get_agent_vars_dataframe().reset_index()
        run_results['Run_ID'] = run_id  # Add run ID to track different runs
        all_results.append(run_results)

    # Combine all results into a single DataFrame
    combined_results = pd.concat(all_results, ignore_index=True)
    return combined_results

# Example usage
n_runs = 1000  # Number of simulation runs
batch_results = run_batch_simulation(model_params, n_runs)
batch_results.head(10)  # Display the first 10 rows of the combined results
```

## Testing with Different Epsilon Values

Lets run the simulation with different $\epsilon$ values (e.g., -1 to 1 in steps) and collect the results in a DataFrame. The DataFrame will include an additional column to track the $\epsilon$ used in each run.

```{python}
def run_simulation_with_different_epsilons(model_params, epsilon_values):
    all_results = []

    for epsilon in epsilon_values:
        model = BoundedConfidenceModel(
            grid_width=model_params['grid_width'],
            grid_height=model_params['grid_height'],
            N=model_params['N'],
            epsilon=epsilon,
            max_agent_step_size=model_params['max_agent_step_size'],
        )
        
        for i in range(model_params['n_iterations']):
            model.step()

        epsilon_results = model.datacollector.get_agent_vars_dataframe().reset_index()
        epsilon_results['Epsilon'] = epsilon  # Add epsilon to track different values
        all_results.append(epsilon_results)

    # Combine all results into a single DataFrame
    combined_results = pd.concat(all_results, ignore_index=True)
    return combined_results

# Example usage
epsilon_values = [-1, -0.5, 0, 0.5, 1]  # List of epsilon values to test
epsilon_results = run_simulation_with_different_epsilons(model_params, epsilon_values)
epsilon_results.head(10)  # Display the first 10 rows of the combined results
```