## SIR Model

```{python}
import mesa
from mesa import Agent, Model
from mesa.time import RandomActivation
from mesa.space import MultiGrid
from mesa.datacollection import DataCollector
from mesa.batchrunner import batch_run
import matplotlib.pyplot as plt
from pprint import pprint
import numpy as np
import pandas as pd
import random
import yaml
import networkx as nx
import seaborn as sns
import matplotlib.pyplot as plt
import icsspy

icsspy.set_style()
random.seed(30)
```


## Define the agent class

```{python}
class SIRAgent(Agent):
    def __init__(self, unique_id, model, recovery_time_range=(8, 12), max_agent_step_size=1):
        super().__init__(unique_id, model)
        self.state = "S"  # All agents start as susceptible
        self.infected_time = 0  # Counter for how long the agent has been infected
        self.recovery_time_range = recovery_time_range  # Tuple for min and max recovery times
        self.max_agent_step_size = max_agent_step_size  # Step size for movement
        self.pos_history = []  # Track agent's position over time
        self.interactions = {}  # Track interactions with a count
        self.infection_duration = 0  # Track how long the agent has been sick

    def step(self):
        if self.state == "I":
            self.infected_time += 1  # Increment the time the agent has been infected
            self.infection_duration += 1  # Increment the infection duration

            # Check if agent is within the recovery window
            if self.infected_time >= self.recovery_time_range[0]:
                if self.random.random() < 0.5 or self.infected_time >= self.recovery_time_range[1]:
                    self.state = "R"  # Recover if within the window or if max time reached

            if self.state == "I":  # Only try to infect others if still infected
                # Try to infect neighbors
                neighbors = self.model.grid.get_neighbors(self.pos, moore=True, include_center=False)
                for neighbor in neighbors:
                    if neighbor.state == "S" and self.random.random() < self.model.infection_rate:
                        neighbor.state = "I"

        # Move to a random neighboring cell with the given step size
        possible_moves = self.model.grid.get_neighborhood(self.pos, moore=True, include_center=False, radius=self.max_agent_step_size)
        new_position = self.random.choice(possible_moves)
        self.model.grid.move_agent(self, new_position)
        self.pos_history.append(new_position)  # Record the new position

        # Record interactions
        neighbors = self.model.grid.get_neighbors(self.pos, moore=True, include_center=False)
        for neighbor in neighbors:
            if neighbor.unique_id in self.interactions:
                self.interactions[neighbor.unique_id] += 1
            else:
                self.interactions[neighbor.unique_id] = 1
```

## Define the model class

```{python}
class SIRModel(Model):
    def __init__(self, grid_width, grid_height, N, infection_rate, recovery_time_range, max_agent_step_size=1, n_initial_infections=1, max_iterations=1000, change_threshold=0.01):
        super().__init__()
        self.num_agents = N
        self.grid = MultiGrid(grid_width, grid_height, True)
        self.schedule = RandomActivation(self)
        self.infection_rate = infection_rate
        self.recovery_time_range = recovery_time_range
        self.max_agent_step_size = max_agent_step_size
        self.max_iterations = max_iterations
        self.current_iteration = 0
        self.change_threshold = change_threshold
        self.previous_infected_ratio = None  # Track the ratio of infected agents in the previous step
        
        # Create agents
        for i in range(self.num_agents):
            step_size = max_agent_step_size if i % 2 == 0 else 1  # Half agents have large step size, half small
            a = SIRAgent(i, self, recovery_time_range, max_agent_step_size=step_size)
            self.grid.place_agent(a, (self.random.randrange(self.grid.width),
                                      self.random.randrange(self.grid.height)))
            a.pos_history.append(a.pos)  # Initialize the position history with the starting position
            self.schedule.add(a)

        # Infect a specified number of random agents
        initial_infected_agents = self.random.sample(self.schedule.agents, n_initial_infections)
        for agent in initial_infected_agents:
            agent.state = "I"
            agent.infected_time = 0  # Initialize infection duration

        self.datacollector = DataCollector(
            model_reporters={"Infected": self.compute_infected},
            agent_reporters={"State": "state", "Infection_Duration": "infection_duration"}  # Collect infection duration
        )
        self.running = True  # Ensure the model runs by default

    def step(self):
        self.datacollector.collect(self)
        self.schedule.step()
        self.current_iteration += 1

        # Check for stopping condition based on maximum iterations
        if self.current_iteration >= self.max_iterations:
            self.running = False

        # Check for stopping condition based on change in infected ratio
        current_infected_ratio = self.compute_infected()
        if self.previous_infected_ratio is not None:
            change = abs(current_infected_ratio - self.previous_infected_ratio)
            if change < self.change_threshold:
                self.running = False
        self.previous_infected_ratio = current_infected_ratio

    def compute_infected(self):
        infected = sum([1 for a in self.schedule.agents if a.state == "I"])
        return infected / self.num_agents

    def get_interaction_graph(self):
        G = nx.Graph()
        for agent in self.schedule.agents:
            G.add_node(agent.unique_id)
            for interacted_agent, count in agent.interactions.items():
                if G.has_edge(agent.unique_id, interacted_agent):
                    G[agent.unique_id][interacted_agent]['weight'] += count
                else:
                    G.add_edge(agent.unique_id, interacted_agent, weight=count)
        return G
```

## Run the model

Load the model parameters

```{python}
with open('_variables.yml', 'r') as file:
    params = yaml.safe_load(file)

model_1_params = params.get('model_1')
pprint(model_1_params)

model_2_params = params.get('model_2')
pprint(model_2_params)
```

and run!

```{python}
model_1 = SIRModel(
    n_initial_infections = model_1_params['n_initial_infections'],
    grid_width = model_1_params['grid_width'],
    grid_height = model_1_params['grid_height'],
    N = model_1_params['N'],
    infection_rate = model_1_params['infection_rate'],
    recovery_time_range = model_1_params['recovery_time_range'],
    max_agent_step_size = model_1_params['max_agent_step_size'],
)

for i in range(model_1_params['n_iterations']):
    model_1.step()

m1res = model_1.datacollector.get_model_vars_dataframe()
```


```{python}
model_2 = SIRModel(
    n_initial_infections = model_2_params['n_initial_infections'],
    grid_width = model_2_params['grid_width'],
    grid_height = model_2_params['grid_height'],
    N = model_2_params['N'],
    infection_rate = model_2_params['infection_rate'],
    recovery_time_range = model_2_params['recovery_time_range'],
    max_agent_step_size = model_2_params['max_agent_step_size'],
)

for i in range(model_2_params['n_iterations']):
    model_2.step()

m2res = model_2.datacollector.get_model_vars_dataframe()
```

## 

Plot the results

```{python}
fig, ax = plt.subplots()
ax.plot(m1res['Infected'], label=r'High transmissability, $\beta$=0.3')
ax.plot(m2res['Infected'], label=r'Low transmissability $\beta$=0.15')
plt.xlabel("\nDiscrete Steps in Time")
plt.ylabel("Proportion Infected\n")
plt.legend(loc='upper right', fontsize=10)
plt.savefig('media/sir_compare_models_1-2.png')
```

![This is @fig-sir_compare from earlier in the lecture. Proportion of infected people in a population over time from two SIR simulations with different transmissability rates.](media/sir_compare){width=100%}


## Model 3

```{python}
model_3_params = params.get('model_3')
pprint(model_3_params['max_agent_step_size'])

model_4_params = params.get('model_4')
pprint(model_4_params['max_agent_step_size'])

model_5_params = params.get('model_5')
pprint(model_5_params['max_agent_step_size'])

model_6_params = params.get('model_6')
pprint(model_6_params['max_agent_step_size'])
```


```{python}
model_3 = SIRModel(
    n_initial_infections = model_3_params['n_initial_infections'],
    grid_width = model_3_params['grid_width'],
    grid_height = model_3_params['grid_height'],
    N = model_3_params['N'],
    infection_rate = model_3_params['infection_rate'],
    recovery_time_range = model_3_params['recovery_time_range'],
    max_agent_step_size = model_3_params['max_agent_step_size'],
)

for i in range(model_3_params['n_iterations']):
    model_3.step()

m3res = model_3.datacollector.get_model_vars_dataframe()
```

## 

```{python}
model_4 = SIRModel(
    n_initial_infections = model_4_params['n_initial_infections'],
    grid_width = model_4_params['grid_width'],
    grid_height = model_4_params['grid_height'],
    N = model_4_params['N'],
    infection_rate = model_4_params['infection_rate'],
    recovery_time_range = model_4_params['recovery_time_range'],
    max_agent_step_size = model_4_params['max_agent_step_size'],
)

for i in range(model_4_params['n_iterations']):
    model_4.step()

m4res = model_4.datacollector.get_model_vars_dataframe()
```


##

```{python}
model_5 = SIRModel(
    n_initial_infections = model_5_params['n_initial_infections'],
    grid_width = model_5_params['grid_width'],
    grid_height = model_5_params['grid_height'],
    N = model_5_params['N'],
    infection_rate = model_5_params['infection_rate'],
    recovery_time_range = model_5_params['recovery_time_range'],
    max_agent_step_size = model_5_params['max_agent_step_size'],
)

for i in range(model_5_params['n_iterations']):
    model_5.step()

m5res = model_5.datacollector.get_model_vars_dataframe()
```

##

```{python}
model_6 = SIRModel(
    n_initial_infections = model_6_params['n_initial_infections'],
    grid_width = model_6_params['grid_width'],
    grid_height = model_6_params['grid_height'],
    N = model_6_params['N'],
    infection_rate = model_6_params['infection_rate'],
    recovery_time_range = model_6_params['recovery_time_range'],
    max_agent_step_size = model_6_params['max_agent_step_size'],
)

for i in range(model_6_params['n_iterations']):
    model_6.step()

m6res = model_6.datacollector.get_model_vars_dataframe()
```

##

Plot the results

```{python}
fig, ax = plt.subplots()
ax.plot(m3res['Infected'], label=f'Max Agent Steps: {model_3_params['max_agent_step_size']}')
ax.plot(m4res['Infected'], label=f'Max Agent Steps: {model_4_params['max_agent_step_size']}')
ax.plot(m5res['Infected'], label=f'Max Agent Steps: {model_5_params['max_agent_step_size']}')
ax.plot(m6res['Infected'], label=f'Max Agent Steps: {model_6_params['max_agent_step_size']}')
plt.title(r'$\beta$=' + f'{model_3_params['infection_rate']} for all models\n', loc='left')
plt.xlabel("\nDiscrete Steps in Time")
plt.ylabel("Proportion Infected\n")
plt.legend(loc='upper right', fontsize=10)
plt.savefig('media/sir_compare_models_3-6.png')
```


<!-- UPDATE _VARIABLES -->

```{python}
#| echo: false
from icsspy.utils import update_quarto_variables

# compute the infection peak for both models so you can use them dynamically in the lecture
update_quarto_variables("results_sir_model_1_max_infected", float(m1res['Infected'].max()))
update_quarto_variables("results_sir_model_2_max_infected", float(m2res['Infected'].max()))
```


## Model Interaction Histories

Get the agent interaction history.

```{python}
interaction_graph_summaries = {}
models = [model_1, model_2, model_3, model_4, model_5, model_6]
for i, model in enumerate(models, start=1):
    wel = []
    for agent in model.schedule.agents:
        for k, v in agent.interactions.items():
            wel.append((int(agent.unique_id), k, v))
    
    G = nx.Graph()
    G.add_weighted_edges_from(wel)  
    avg_degree = round(sum(dict(G.degree()).values()) / float(G.number_of_nodes()), 2)
    interaction_graph_summaries[i] = (G.number_of_nodes(), G.number_of_edges(), avg_degree)

interaction_graph_summaries = pd.DataFrame(interaction_graph_summaries).T
interaction_graph_summaries.columns = ['No. Nodes', 'No. Edges', 'Avg. Degree']
interaction_graph_summaries
```

```{python}
#| echo: false
from icsspy.utils import markdown_table
md = markdown_table(interaction_graph_summaries, 'tables/_sir_1_interaction_graph_summaries.md')
print(md)
```




```{python}
for agent in model_6.schedule.agents:
    print(f"Agent {agent.unique_id} interactions: {agent.interactions}")
```

Plot agent interaction networks.

```{python}
# Initialize an empty graph
G = nx.Graph()

# Add nodes and edges based on interactions
for agent in model_6.schedule.agents:
    G.add_node(agent.unique_id)  # Add agent as a node
    for interacted_agent, count in agent.interactions.items():
        if G.has_edge(agent.unique_id, interacted_agent):
            G[agent.unique_id][interacted_agent]['weight'] += count
        else:
            G.add_edge(agent.unique_id, interacted_agent, weight=count)
```

```{python}
print(f"Number of nodes: {G.number_of_nodes()}")
print(f"Number of edges: {G.number_of_edges()}")
print(f"Average degree: {sum(dict(G.degree()).values()) / float(G.number_of_nodes())}")
```

```{python}
# Extract the edge weights
weights = [d['weight'] for u, v, d in G.edges(data=True)]

plt.figure(figsize=(8, 6))
sns.ecdfplot(weights)
plt.xlabel('Interaction Weight')
plt.ylabel('ECDF')
plt.title('ECDF of Interaction Weights')
plt.grid(True)
plt.savefig('media/compare_agent_networks.png', dpi=300)
```


## Plot the random walks for an agent with low steps (agent 7) and high-steps.

```{python}
# Find the agent with unique_id = 7
agent_id_7 = 29
agent_7 = next(agent for agent in model_6.schedule.agents if agent.unique_id == agent_id_7)

# Find another agent with a larger step size
larger_step_agent = max(model_6.schedule.agents, key=lambda agent: agent.max_agent_step_size)

# Create subplots
fig, axs = plt.subplots(1, 2, figsize=(24, 12))

# Plot agent 7's trajectory in the first subplot
x7, y7 = zip(*agent_7.pos_history)
axs[0].plot(x7, y7, label=f"Agent {agent_7.unique_id} (Step size: {agent_7.max_agent_step_size})", color='blue')
axs[0].set_title(f"Agent {agent_7.unique_id} (Step size: {agent_7.max_agent_step_size})")
axs[0].set_xlabel("X Position")
axs[0].set_ylabel("Y Position")
axs[0].grid(True, which='both', linestyle='--')  # Show grid lines at every tick
axs[0].minorticks_on()  # Ensure minor ticks are on for finer grid control
axs[0].set_xlim(-0.5, 40.5)
axs[0].set_ylim(-0.5, 40.5)
axs[0].set_yticks(np.arange(0, 41, 2))  # Set y-axis ticks to every 2nd number
axs[0].set_xticks(np.arange(0, 41, 2))  # Set x-axis ticks to every 2nd number

# Plot the larger step agent's trajectory in the second subplot
x_large, y_large = zip(*larger_step_agent.pos_history)
axs[1].plot(x_large, y_large, label=f"Agent {larger_step_agent.unique_id} (Step size: {larger_step_agent.max_agent_step_size})", color='red')
axs[1].set_title(f"Agent {larger_step_agent.unique_id} (Step size: {larger_step_agent.max_agent_step_size})")
axs[1].set_xlabel("X Position")
axs[1].set_ylabel("Y Position")
axs[1].grid(True, which='both', linestyle='--')  # Show grid lines at every tick
axs[1].minorticks_on()  # Ensure minor ticks are on for finer grid control
axs[1].set_xlim(-0.5, 40.5)
axs[1].set_ylim(-0.5, 40.5)
axs[1].set_yticks(np.arange(0, 41, 2))  # Set y-axis ticks to every 2nd number
axs[1].set_xticks(np.arange(0, 41, 2))  # Set x-axis ticks to every 2nd number

# Adjust layout and show plot
plt.tight_layout()
plt.savefig('media/compare_agent_step_sizes.png', dpi=300)
```

![](media/media/compare_agent_step_sizes.png){width=100%}


# Sensitivity Analysis and Parameter Sweeps with BatchRunner


```{python}
params = {
    "N": 100,  
    "grid_height": 40,
    "grid_width": 40,
    "infection_rate": 0.45,
    "recovery_time_range": [(14,24)],
    "max_agent_step_size": [2,4,6,8,10,12,14,16,18,20], 
}

results = mesa.batch_run(
    SIRModel,  # Your model class
    parameters=params,
    iterations=10,  # Number of iterations per parameter combination
    max_steps=100,  # Number of steps in each simulation
    number_processes=4,  # Use 4 CPU cores for parallel processing
    data_collection_period=1,  # Collect data at every step
    display_progress=True,  # Show progress bar during execution
)

# Convert results to DataFrame for analysis
results_df = pd.DataFrame(results)
results_df
```

```{python}

# Check the first few rows of the DataFrame
print(results_df.head())

# Check if there are any rows where State is 'R' and Infection_Duration is non-null
recovered_agents = results_df[results_df['State'] == 'R']
print(recovered_agents[['Infection_Duration', 'State']].dropna())
```




```{python}
# Assuming results_df contains the batch run results
infection_durations = results_df[results_df['State'] == 'R']['Infection_Duration']
plt.figure(figsize=(10, 6))
sns.histplot(infection_durations, kde=True)
plt.title('Distribution of Infection Duration')
plt.xlabel('Infection Duration (Steps)')
plt.ylabel('Frequency')
plt.show()
```

```{python}
plt.figure(figsize=(10, 6))
sns.ecdfplot(infection_durations)
plt.title('Cumulative Distribution of Infection Duration')
plt.xlabel('Infection Duration (Steps)')
plt.ylabel('Cumulative Frequency')
plt.show()
```


## Batch No. 2

```{python}
params = {
    "N": 100,  
    "grid_height": 40,
    "grid_width": 40,
    "infection_rate": [0.1, 0.2, 0.3, 0.4, 0.5, 0.55, 0.6, 0.7, 0.8, 0.9],
    "recovery_time_range": [(14,24)],
    "max_agent_step_size": [4, 8, 12, 16], 
}

results = mesa.batch_run(
    SIRModel,  # Your model class
    parameters=params,
    iterations=10,  # Number of iterations per parameter combination
    max_steps=100,  # Number of steps in each simulation
    number_processes=4,  # Use 4 CPU cores for parallel processing
    data_collection_period=1,  # Collect data at every step
    display_progress=True,  # Show progress bar during execution
)

# Convert results to DataFrame for analysis
results_df = pd.DataFrame(results)
results_df
```


```{python}

# Check the first few rows of the DataFrame
print(results_df.head())

# Check if there are any rows where State is 'R' and Infection_Duration is non-null
recovered_agents = results_df[results_df['State'] == 'R']
print(recovered_agents[['Infection_Duration', 'State']].dropna())
```




```{python}
# Assuming results_df contains the batch run results
infection_durations = results_df[results_df['State'] == 'R']['Infection_Duration']
plt.figure(figsize=(10, 6))
sns.histplot(infection_durations, kde=True)
plt.title('Distribution of Infection Duration')
plt.xlabel('Infection Duration (Steps)')
plt.ylabel('Frequency')
plt.show()
```


```{python}
plt.figure(figsize=(10, 6))
sns.ecdfplot(infection_durations)
plt.title('Cumulative Distribution of Infection Duration')
plt.xlabel('Infection Duration (Steps)')
plt.ylabel('Cumulative Frequency')
plt.show()
```


```{python}
avg_duration_by_rate = recovered_agents.groupby('infection_rate')['Infection_Duration'].mean()

plt.figure(figsize=(10, 6))
plt.plot(avg_duration_by_rate.index, avg_duration_by_rate.values, marker='o')
plt.title('Average Infection Duration vs. Infection Rate')
plt.xlabel('Infection Rate')
plt.ylabel('Average Infection Duration (Steps)')
plt.show()
```

```{python}
final_infected_by_rate = results_df.groupby('infection_rate')['Infected'].last()

plt.figure(figsize=(10, 6))
plt.plot(final_infected_by_rate.index, final_infected_by_rate.values, marker='o')
plt.title('Final Proportion Infected vs. Infection Rate')
plt.xlabel('Infection Rate')
plt.ylabel('Final Proportion Infected')
plt.show()
```

```{python}
plt.figure(figsize=(12, 8))
sns.boxplot(x='infection_rate', y='Infection_Duration', data=recovered_agents)
plt.title('Boxplot of Infection Durations for Different Infection Rates')
plt.xlabel('Infection Rate')
plt.ylabel('Infection Duration (Steps)')
plt.show()
```


```{python}
heatmap_data = results_df.pivot_table(index='max_agent_step_size', columns='infection_rate', values='Infected', aggfunc='last')

plt.figure(figsize=(10, 8))
sns.heatmap(heatmap_data, annot=True, cmap='viridis')
plt.title('Heatmap of Final Proportion Infected vs. Infection Rate and Agent Step Size')
plt.xlabel('Infection Rate')
plt.ylabel('Max Agent Step Size')
plt.show()
```

```{python}
fig, axs = plt.subplots(1, 2, figsize=(24, 12))

# Agent 7
x7, y7 = zip(*agent_7.pos_history)
axs[0].plot(x7, y7, label=f"Agent {agent_7.unique_id} (Step size: {agent_7.max_agent_step_size})", color='blue')
axs[0].set_title(f"Agent {agent_7.unique_id} (Step size: {agent_7.max_agent_step_size})")
axs[0].set_xlabel("X Position")
axs[0].set_ylabel("Y Position")
axs[0].grid(True, which='both', linestyle='--')

# Larger step agent
x_large, y_large = zip(*larger_step_agent.pos_history)
axs[1].plot(x_large, y_large, label=f"Agent {larger_step_agent.unique_id} (Step size: {larger_step_agent.max_agent_step_size})", color='red')
axs[1].set_title(f"Agent {larger_step_agent.unique_id} (Step size: {larger_step_agent.max_agent_step_size})")
axs[1].set_xlabel("X Position")
axs[1].set_ylabel("Y Position")
axs[1].grid(True, which='both', linestyle='--')

plt.tight_layout()
plt.savefig('media/compare_agent_step_sizes.png', dpi=300)
plt.show()
```

```{python}
# Extract the edge weights
weights = [d['weight'] for u, v, d in G.edges(data=True)]

plt.figure(figsize=(8, 6))
sns.ecdfplot(weights)
plt.xlabel('Interaction Weight')
plt.ylabel('ECDF')
plt.title('ECDF of Interaction Weights')
plt.grid(True)
plt.savefig('media/compare_agent_networks.png', dpi=300)
plt.show()
```

## Comparing Batch Runs

```{python}
# Compute mean and variance of infection durations by infection rate
mean_duration = results_df.groupby('infection_rate')['Infection_Duration'].mean()
var_duration = results_df.groupby('infection_rate')['Infection_Duration'].var()

# Plot the mean and variance
plt.figure(figsize=(12, 6))
plt.plot(mean_duration.index, mean_duration.values, label='Mean Infection Duration', marker='o')
plt.fill_between(mean_duration.index, mean_duration.values - np.sqrt(var_duration.values),
                 mean_duration.values + np.sqrt(var_duration.values), alpha=0.3)
plt.title('Mean and Variance of Infection Duration by Infection Rate')
plt.xlabel('Infection Rate')
plt.ylabel('Infection Duration (Steps)')
plt.legend(loc='best')
plt.show()
```

```{python}
plt.figure(figsize=(12, 8))
for rate in params['infection_rate']:
    subset = results_df[(results_df['infection_rate'] == rate) & (results_df['Step'] > 0)]
    mean_infected = subset.groupby('Step')['Infected'].mean()
    plt.plot(mean_infected.index, mean_infected.values, label=f"Infection Rate: {rate}")

plt.title('Time Series of Proportion Infected Across Different Infection Rates')
plt.xlabel('Time Step')
plt.ylabel('Proportion Infected')
plt.legend(loc='best')
plt.show()
```

```{python}
plt.figure(figsize=(12, 8))
sns.boxplot(x='infection_rate', y='Infected', data=results_df[results_df['Step'] == results_df['Step'].max()])
plt.title('Boxplot of Final Proportion Infected Across Infection Rates')
plt.xlabel('Infection Rate')
plt.ylabel('Final Proportion Infected')
plt.show()
```

```{python}
heatmap_data = results_df.pivot_table(index='max_agent_step_size', columns='infection_rate', values='Infected', aggfunc='mean')

plt.figure(figsize=(10, 8))
sns.heatmap(heatmap_data, annot=True, cmap='viridis')
plt.title('Heatmap of Final Proportion Infected by Infection Rate and Step Size')
plt.xlabel('Infection Rate')
plt.ylabel('Max Agent Step Size')
plt.show()
```

```{python}
plt.figure(figsize=(12, 8))
for rate in params['infection_rate']:
    subset = recovered_agents[recovered_agents['infection_rate'] == rate]
    sns.ecdfplot(subset['Infection_Duration'], label=f"Infection Rate: {rate}")

plt.title('CDF of Infection Durations Across Different Infection Rates')
plt.xlabel('Infection Duration (Steps)')
plt.ylabel('Cumulative Frequency')
plt.legend(loc='best')
plt.show()
```

```{python}
sns.pairplot(results_df, hue='infection_rate', vars=['Infection_Duration', 'Infected'])
plt.suptitle('Pairwise Scatter Plot of Outcomes by Infection Rate')
plt.show()
```



```{python}
summary_table = results_df.groupby('infection_rate').agg({
    'Infection_Duration': ['mean', 'median', 'var', 'min', 'max'],
    'Infected': ['mean', 'median', 'var', 'min', 'max']
})

print(summary_table)
```


```{python}
plt.figure(figsize=(12, 8))
for iteration in results_df['iteration'].unique():
    subset = results_df[(results_df['iteration'] == iteration)]
    plt.plot(subset['Step'], subset['Infected'], alpha=0.5, label=f"Run {iteration}")

plt.title('Overlay of Proportion Infected Across Multiple Runs')
plt.xlabel('Time Step')
plt.ylabel('Proportion Infected')
plt.legend(loc='best', fontsize=8)
plt.show()
```
