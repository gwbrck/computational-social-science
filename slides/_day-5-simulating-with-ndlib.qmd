## Imports

```{python}
import random
import numpy as np
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
import matplotlib.colors as mcolors
import graph_tool.all as gt
import networkx as nx

import ndlib.models.ModelConfig as mc
import ndlib.models.epidemics as ep
from ndlib.utils import multi_runs

import icsspy
import icsspy.simulations as sims
from icsspy.utils import estimate_meters_from_rssi
import icsspy.plotting as plotting

icsspy.set_style()
random.seed(36)
```

## Data

```{python}
bluetooth_contact = icsspy.load_data('cns_bluetooth_filtered') 
bluetooth_contact = bluetooth_contact[bluetooth_contact['rssi'] <= 0] # mistake in recorded data
bluetooth_contact.head()
```

## Interactions in Time [(Timestamp)]{.kn-light}

These timestamps are relative, not absolute; they don't correspond to specific dates or times, they represent the number of seconds since the beginning of the study. They are quantized into 5-minute bins (300 seconds), where each timestamp represents the start of a 5-minute period where interactions were recorded. This means that the timestamps are best understood as **relative durations** of interactions. 

However, we can treat them as if they did correspond to specific dates and times by giving them an arbitrary start date that we will treat as the beginning of the study. We don't actually care about these dates, since they are not real, but it is convienit to work with the data this way.

```{python}
arbitrary_start_date = pd.to_datetime('2019-01-01')
bluetooth_contact['processed_timestamp'] = arbitrary_start_date + pd.to_timedelta(
    bluetooth_contact['# timestamp'], unit='s'
)

bluetooth_contact.sample(10)
```

## Time and Distance

Let's select two users that we know have frequent interactions with one another. We'll plot the distance between these two users over a two week duration (the range of this data). To do so, we'll sort the rows (this is undirected), group by the pair of users, and count the interactions. We'll then sort the resulting dataframe to see the most frequently interacting pairs.

```{python}
bluetooth_contact['user_pair'] = bluetooth_contact.apply(
    lambda row: tuple(sorted([row['user_a'], row['user_b']])), axis=1
)

pair_counts = bluetooth_contact.groupby('user_pair').size().reset_index(name='counts')
pair_counts = pair_counts.sort_values(by='counts', ascending=False)
pair_counts.head(10)
```

We'll work with the top pair.

```{python}
frequent_pair = pair_counts.iloc[0] 
user1, user2 = frequent_pair['user_pair']
print(f"Selected users with frequent interactions: {user1} and {user2}")
```

## Time and Distance

Let's get their interactions from the larger dataframe. 

```{python}
filtered_data = bluetooth_contact[
    ((bluetooth_contact['user_a'] == user1) & (bluetooth_contact['user_b'] == user2)) |
    ((bluetooth_contact['user_a'] == user2) & (bluetooth_contact['user_b'] == user1))
]

# sort by timestamp for plotting
filtered_data = filtered_data.sort_values(by='processed_timestamp')
filtered_data.head()
```

Let's convert the RSSI values to an estimated distance (meters). We'll use the Log-Distance Path Loss Model to do this, but it will be imperfect because we can't adjust the parameters based on the environmental context (indoors, outdoors, etc.) since we don't know that information. The conversion to meters is done using the model below.

```{python}
filtered_data['estimated_meters'] = estimate_meters_from_rssi(filtered_data, 'rssi')
filtered_data
```

## 

Create a timeseries with 5-minute intervals; NaN if not present.

```{python}
time_range = pd.date_range(
    start=filtered_data['processed_timestamp'].min().floor('min'),
    end=filtered_data['processed_timestamp'].max().ceil('min'),
    freq='5min' # 5 min intervals
)

# convert the dataframe with intervals
time_series_df = pd.DataFrame(time_range, columns=['processed_timestamp'])

# round the timestamps in the filtered data to the nearest 5-minute interval
filtered_data['rounded_timestamp'] = filtered_data['processed_timestamp'].dt.round('5min')

# merge the two dataframes
merged_df = pd.merge(time_series_df, filtered_data[['rounded_timestamp', 'estimated_meters']],
                     left_on='processed_timestamp', right_on='rounded_timestamp', how='left')

# drop the extra column created by the merge
merged_df.drop(columns=['rounded_timestamp'], inplace=True)


merged_df
```

::: {.notes}
With this approach, even if an interaction occurs slightly before or after a 5-minute boundary, it will still be counted in the nearest 5-minute bin, preventing any gaps or inaccuracies in the distance data. The final DataFrame will accurately reflect the estimated distances between the selected users at each 5-minute interval, including interactions that donâ€™t line up perfectly with the original bins.
:::


## Interactions in Space [(RSSI)]{.kn-light}

Now let's plot the estimated distances between these two users over time.

We'll use the `plot_distance_per_day()` function from the course package, since the code to produce this figure is fairly complex and the specifics are beyond the scope of this course (and irrelevant to the task at hand anyway).

```python
plotting.plot_distance_per_day(
    merged_df, 
    time_col='processed_timestamp', 
    distance_col='estimated_meters', 
    num_segments=15,
    filename='media/colocations_two_users_two_weeks.png'
)
```


## Participants in Time and Space

:::: {.columns}
::: {.column width="75%"}
![What explanations are there for this temporal pattern of co-location?](media/colocations_two_users_two_weeks.png){width=100% #fig-colocations_two_users_two_weeks}
:::
::: {.column width="25%"}
Let's look at the physical co-locations of two participants. Remeber, we've selected two participants -- `{python} user1` and `{python} user2` -- who spend more time together than any other pair in the data.
:::
::::
