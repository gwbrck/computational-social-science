{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# Mesa {background-image=media/robot.jpg}\n",
        "\n",
        "Developing Your First ABM\n",
        "\n",
        "\n",
        "## An MED of OOP for ABM [(sorry...)]{.nord-light}\n",
        "\n",
        "[Object-oriented Programming (OOP), Essential Concepts]{.nord-footer}\n",
        "\n",
        "<br>\n",
        "\n",
        ":::: {.columns}\n",
        "\n",
        "::: {.column width=\"35%\"}\n",
        "![[Photo by <a href=\"https://unsplash.com/@fairfilter?utm_content=creditCopyText&utm_medium=referral&utm_source=unsplash\">Oliver Roos</a> on <a href=\"https://unsplash.com/photos/landscape-photography-of-splitted-road-surrounded-with-trees-PCNdauVPbjA?utm_content=creditCopyText&utm_medium=referral&utm_source=unsplash\">Unsplash</a>]{.nord-light}](media/oliver-roos-PCNdauVPbjA-unsplash.jpg){width=\"100%\"}\n",
        ":::\n",
        "\n",
        "::: {.column width=\"65%\"}\n",
        "- **Classes** are like blueprints for creating objects (e.g., a Person class defines what properties and behaviors a person has). \n",
        "- **Objects** are specific instances of a class (e.g., `maria = Person()` creates an object `maria` from the `Person` class).\n",
        "- **Attributes** are variables that store data specific to an object (e.g., alice.age). \n",
        "- **Methods** are functions that define behaviors of an object (e.g., `alice.move()`).\n",
        "- **Inheritance** allows one class to inherit attributes and methods from another class, promoting code reuse (e.g., Professor class inherits from Person, because professors are people too).\n",
        "- **Encapsulation** allows us to bundle data (attributes) and methods that operate on the data into a single unit or class, restricting direct access to some of an object’s components.\n",
        ":::\n",
        "::::\n",
        "\n",
        "::: {.notes}\n",
        "Introduction to OOP:\n",
        "\n",
        "- Object-Oriented Programming (OOP) is a programming paradigm that structures software design around data, or objects, rather than functions and logic. It’s especially useful for modeling complex systems, like those you’ll encounter in agent-based modeling (ABM).\n",
        "\n",
        "Classes and Objects:\n",
        "\n",
        "- Think of a class as a blueprint. For example, if you’re modeling a group of people, the class might be Person. This class defines the properties (e.g., age, location) and behaviors (e.g., move, speak) that every person should have.\n",
        "- An object is a specific instance of that class. If you were to create a person named Alice in your model, you would instantiate the Person class like this: alice = Person(). Now, alice is an object with her own specific age, location, and so on.\n",
        "\n",
        "Attributes and Methods:\n",
        "\n",
        "- Attributes are like variables that hold information about the object. For example, alice.age = 25 sets Alice’s age to 25. Each object can have different values for these attributes.\n",
        "- Methods are functions that belong to the class and define what an object can do. For example, alice.move() could be a method that changes Alice’s location within the simulation.\n",
        "\n",
        "Inheritance:\n",
        "\n",
        "- Inheritance allows you to create a new class that is based on an existing class. If you have a Worker class that should include everything a Person has, but with some additional features, you can create Worker as a subclass of Person. This means Worker inherits all attributes and methods from Person but can also have its own unique features. This is crucial in ABM, where you might have different types of agents with shared behaviors.\n",
        "\n",
        "Encapsulation:\n",
        "\n",
        "- Encapsulation is the idea of keeping the internal workings of an object hidden from the outside. You can think of it as protecting the data inside an object. For example, you might not want other parts of your program to change an agent’s age directly; instead, they might call a method that safely updates the age. Encapsulation helps maintain the integrity of your model’s data and logic.\n",
        "\n",
        "Applying OOP in Mesa:\n",
        "\n",
        "- When you move to Mesa, you’ll use these OOP principles to define your agents as classes. Each agent will be an object of its class, with attributes that define its state (like position or health) and methods that define its behavior (like move() or interact()).\n",
        "- You’ll also use inheritance to create different types of agents with shared and unique behaviors, which makes your model more scalable and easier to manage.\n",
        "\n",
        "In short, OOP is fundamental for structuring your agent-based models in Python. By organizing your code into classes and objects, you can create agents with complex behaviors and interactions that are both manageable and scalable, which is exactly what you’ll be doing in Mesa.\n",
        ":::\n",
        "\n",
        "## Agent-based Modelling with Mesa\n",
        "\n",
        "[Object-oriented Programming (OOP), Essential Concepts]{.nord-footer}\n",
        "\n",
        "<br>\n",
        "\n",
        ":::: {.columns}\n",
        "::: {.column width=\"45%\"}\n",
        "- We define an [Agent Class]{.kn-pink} [(which inherits from a more general Mesa class)]{.nord-light}. Each agent created from our class is an **object** with **attributes** [(states)]{.nord-light} and **methods** [(behaviors)]{.nord-light}.\n",
        "- The **environment** is typically represented as a grid or network where agents interact. The [Model class]{.kn-pink} manages the overall simulation, including initializing agents, updating them each step, and collecting data.\n",
        "- The Mesa [Scheduler]{.kn-pink} determines the order in which agents act. Common options include random or sequential activation. Agents execute their actions and update their states in each step of the schedule [(i.e., a tick of time)]{.nord-light}. \n",
        "- The Mesa [DataCollector]{.kn-pink} is used to gather and store data during the simulation for analysis.\n",
        ":::\n",
        "\n",
        "::: {.column width=\"10%\"}\n",
        ":::\n",
        "\n",
        "::: {.column width=\"45%\"}\n",
        "![](media/robot.jpg){width=\"100%\" .shadow-img}\n",
        "\n",
        "[Agents are like little robots we manufactor according to some set of explicit instructions (the agent class).]{.nord-footer}\n",
        ":::\n",
        "::::\n",
        "\n",
        "::: {.notes}\n",
        "When we build agent-based models with Mesa, we apply these OOP concepts. Each agent in our models are instances of a class, meaning it has specific attributes and methods that define how it behaves in the simulation. In our SIR model, for example, each agent has a state attribute that indicates whether the agent is currently susceptible, infected, or in recovery.\n",
        "\n",
        "The environment where our agents interact is managed by the Model class. This environment could be a grid (like a city map) or a network (like social connections). The Model class handles the setup, including creating agents and placing them in the environment, and it oversees the simulation process.\n",
        "\n",
        "The Scheduler in Mesa is key to controlling how and when agents act. You can set agents to act in a random order, which might simulate more realistic scenarios, or in a specific sequence, depending on what makes sense for your model. This scheduling allows the simulation to evolve dynamically as agents interact with each other and the environment. Throughout the simulation, you can use the DataCollector to track various metrics—like the number of infected individuals in our SIR model. This data is crucial for analyzing the outcomes of your model. \n",
        "\n",
        "With that, let's get into things!\n",
        ":::\n",
        "\n",
        "\n",
        "##\n",
        "\n",
        "<br><br>\n",
        "\n",
        ":::: {.columns}\n",
        "::: {.column width=\"35%\"}\n",
        "![ChatGPT / DALL-E3's artistic rendering of \"dependency hell.\"](media/chatgpt_dependency_hell.png){.shadow-img width=100%}\n",
        ":::\n",
        "\n",
        "::: {.column width=\"5%\"}\n",
        ":::\n",
        "\n",
        "::: {.column width=\"60%\"}\n",
        "First, we set up our environment. We'll continue using the `gt` environment from yesterday. If you created it from the `setup/graphtool.yml` file, it has everything we need.\n",
        "\n",
        "<br>\n",
        "\n",
        "```zsh\n",
        "cd computational-social-science\n",
        "conda env create -f setup/graphtool.yaml\n",
        "conda activate gt\n",
        "```\n",
        "\n",
        ":::\n",
        "::::\n",
        "\n",
        "\n",
        "## \n",
        "\n",
        ":::: {.columns}\n",
        "::: {.column width=\"40%\"}\n",
        "<br><br>\n",
        "\n",
        "Let's develop the \n",
        "\n",
        "### SIR model \n",
        "\n",
        "we've been using as an example so far.\n",
        ":::\n",
        "\n",
        "::: {.column width=\"5%\"}\n",
        ":::\n",
        "\n",
        "::: {.column width=\"55%\"}"
      ],
      "id": "124d35f9"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import mesa\n",
        "from mesa import Agent, Model\n",
        "from mesa.time import RandomActivation\n",
        "from mesa.space import MultiGrid\n",
        "from mesa.datacollection import DataCollector\n",
        "from mesa.batchrunner import batch_run\n",
        "import matplotlib.pyplot as plt\n",
        "from pprint import pprint\n",
        "import numpy as np\n",
        "import pandas as pd\n",
        "import random\n",
        "import yaml\n",
        "import networkx as nx\n",
        "import seaborn as sns\n",
        "import matplotlib.pyplot as plt\n",
        "import icsspy"
      ],
      "id": "c5adaad7",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "<br>\n",
        "\n",
        "Set a seed, for reproducibility, and [(optionally)]{.nord-light} use `icsspy.set_style()` to style your plots like mine.\n"
      ],
      "id": "206d9ec3"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "random.seed(30)\n",
        "icsspy.set_style()"
      ],
      "id": "53bd3325",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        ":::\n",
        "::::\n",
        "\n",
        "\n",
        "## First, define the [agent class]{.kn-pink}\n",
        "\n",
        "<br>\n"
      ],
      "id": "a56b55eb"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "class SIRAgent(Agent):\n",
        "    def __init__(\n",
        "        self, \n",
        "        unique_id, \n",
        "        model, \n",
        "        recovery_time_range=(8, 12), \n",
        "        max_agent_step_size=1\n",
        "    ):\n",
        "\n",
        "        super().__init__(unique_id, model)\n",
        "        self.state = \"S\"  # All agents start as susceptible\n",
        "        self.infected_time = 0  # Counter for how long the agent has been infected\n",
        "        self.recovery_time_range = recovery_time_range  # Tuple for min and max recovery times\n",
        "        self.max_agent_step_size = max_agent_step_size  # Step size for movement\n",
        "        self.pos_history = []  # Track agent's position over time\n",
        "        self.interactions = {}  # Track interactions with a count\n",
        "        self.infection_duration = 0  # Track how long the agent has been sick\n",
        "\n",
        "    def step(self):\n",
        "        if self.state == \"I\":\n",
        "            self.infected_time += 1  # Increment the time the agent has been infected\n",
        "            self.infection_duration += 1  # Increment the infection duration\n",
        "\n",
        "            # Check if agent is within the recovery window\n",
        "            if self.infected_time >= self.recovery_time_range[0]:\n",
        "                if self.random.random() < 0.5 or self.infected_time >= self.recovery_time_range[1]:\n",
        "                    self.state = \"R\"  # Recover if within the window or if max time reached\n",
        "\n",
        "            if self.state == \"I\":  # Only try to infect others if still infected\n",
        "                # Try to infect neighbors\n",
        "                neighbors = self.model.grid.get_neighbors(self.pos, moore=True, include_center=False)\n",
        "                for neighbor in neighbors:\n",
        "                    if neighbor.state == \"S\" and self.random.random() < self.model.infection_rate:\n",
        "                        neighbor.state = \"I\"\n",
        "\n",
        "        # Move to a random neighboring cell with the given step size\n",
        "        possible_moves = self.model.grid.get_neighborhood(\n",
        "            self.pos, moore=True, include_center=False, radius=self.max_agent_step_size\n",
        "        )\n",
        "        new_position = self.random.choice(possible_moves)\n",
        "        self.model.grid.move_agent(self, new_position)\n",
        "        self.pos_history.append(new_position)  # Record the new position\n",
        "\n",
        "        # Record interactions\n",
        "        neighbors = self.model.grid.get_neighbors(\n",
        "            self.pos, moore=True, include_center=False\n",
        "        )\n",
        "        for neighbor in neighbors:\n",
        "            if neighbor.unique_id in self.interactions:\n",
        "                self.interactions[neighbor.unique_id] += 1\n",
        "            else:\n",
        "                self.interactions[neighbor.unique_id] = 1"
      ],
      "id": "4b4ecedb",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Second, define the [model class]{.kn-pink}\n",
        "\n",
        "<br>\n"
      ],
      "id": "69cc3f10"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "class SIRModel(Model):\n",
        "    def __init__(\n",
        "        self, \n",
        "        grid_width, \n",
        "        grid_height, \n",
        "        N, \n",
        "        infection_rate, \n",
        "        recovery_time_range, \n",
        "        max_agent_step_size=1, \n",
        "        n_initial_infections=1, \n",
        "        max_iterations=1000, \n",
        "        change_threshold=0.01\n",
        "    ):\n",
        "\n",
        "        super().__init__()\n",
        "        self.num_agents = N\n",
        "        self.grid = MultiGrid(grid_width, grid_height, True)\n",
        "        self.schedule = RandomActivation(self)\n",
        "        self.infection_rate = infection_rate\n",
        "        self.recovery_time_range = recovery_time_range\n",
        "        self.max_agent_step_size = max_agent_step_size\n",
        "        self.max_iterations = max_iterations\n",
        "        self.current_iteration = 0\n",
        "        self.change_threshold = change_threshold\n",
        "        self.previous_infected_ratio = None  # Track the ratio of infected agents in the previous step\n",
        "        \n",
        "        # Create agents\n",
        "        for i in range(self.num_agents):\n",
        "            step_size = max_agent_step_size if i % 2 == 0 else 1  # Half agents have large step size, half small\n",
        "            a = SIRAgent(i, self, recovery_time_range, max_agent_step_size=step_size)\n",
        "            self.grid.place_agent(a, (self.random.randrange(self.grid.width),\n",
        "                                      self.random.randrange(self.grid.height)))\n",
        "            a.pos_history.append(a.pos)  # Initialize the position history with the starting position\n",
        "            self.schedule.add(a)\n",
        "\n",
        "        # Infect a specified number of random agents\n",
        "        initial_infected_agents = self.random.sample(\n",
        "            self.schedule.agents, n_initial_infections\n",
        "        )\n",
        "        for agent in initial_infected_agents:\n",
        "            agent.state = \"I\"\n",
        "            agent.infected_time = 0  # Initialize infection duration\n",
        "\n",
        "        self.datacollector = DataCollector(\n",
        "            model_reporters={\"Infected\": self.compute_infected},\n",
        "            agent_reporters={\"State\": \"state\", \"Infection_Duration\": \"infection_duration\"}  \n",
        "        )\n",
        "        self.running = True  # Ensure the model runs by default\n",
        "\n",
        "    def step(self):\n",
        "        self.datacollector.collect(self)\n",
        "        self.schedule.step()\n",
        "        self.current_iteration += 1\n",
        "\n",
        "        # Check for stopping condition based on maximum iterations\n",
        "        if self.current_iteration >= self.max_iterations:\n",
        "            self.running = False\n",
        "\n",
        "        # Check for stopping condition based on change in infected ratio\n",
        "        current_infected_ratio = self.compute_infected()\n",
        "        if self.previous_infected_ratio is not None:\n",
        "            change = abs(current_infected_ratio - self.previous_infected_ratio)\n",
        "            if change < self.change_threshold:\n",
        "                self.running = False\n",
        "        self.previous_infected_ratio = current_infected_ratio\n",
        "\n",
        "    def compute_infected(self):\n",
        "        infected = sum([1 for a in self.schedule.agents if a.state == \"I\"])\n",
        "        return infected / self.num_agents\n",
        "\n",
        "    def get_interaction_graph(self):\n",
        "        G = nx.Graph()\n",
        "        for agent in self.schedule.agents:\n",
        "            G.add_node(agent.unique_id)\n",
        "            for interacted_agent, count in agent.interactions.items():\n",
        "                if G.has_edge(agent.unique_id, interacted_agent):\n",
        "                    G[agent.unique_id][interacted_agent]['weight'] += count\n",
        "                else:\n",
        "                    G.add_edge(agent.unique_id, interacted_agent, weight=count)\n",
        "        return G"
      ],
      "id": "285c46d6",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Third, load the [model parameters]{.kn-pink}\n",
        "\n",
        "<br>\n"
      ],
      "id": "d75acdea"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "with open('_variables.yml', 'r') as file:\n",
        "    params = yaml.safe_load(file)\n",
        "\n",
        "model_1_params = params.get('model_1')\n",
        "pprint(model_1_params)"
      ],
      "id": "bc98ce2b",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "> output\n",
        "\n",
        "<br>\n"
      ],
      "id": "029c4762"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "model_2_params = params.get('model_2')\n",
        "pprint(model_2_params)"
      ],
      "id": "9e78e94f",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "> output\n",
        "\n",
        "## Forth, [run the model(s)]{.kn-pink}\n",
        "\n",
        "<br>\n",
        "\n",
        "We'll run two models here to reproduce @fig-sir_compare. \n",
        "\n",
        "Here's **Model 1**\n",
        "\n",
        "<br>\n"
      ],
      "id": "4688d432"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "model_1 = SIRModel(\n",
        "    n_initial_infections = model_1_params['n_initial_infections'],\n",
        "    grid_width = model_1_params['grid_width'],\n",
        "    grid_height = model_1_params['grid_height'],\n",
        "    N = model_1_params['N'],\n",
        "    infection_rate = model_1_params['infection_rate'],\n",
        "    recovery_time_range = model_1_params['recovery_time_range'],\n",
        "    max_agent_step_size = model_1_params['max_agent_step_size'],\n",
        ")\n",
        "\n",
        "for i in range(model_1_params['n_iterations']):\n",
        "    model_1.step()\n",
        "\n",
        "m1res = model_1.datacollector.get_model_vars_dataframe()"
      ],
      "id": "bf83eb4e",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Forth, [run the model(s)]{.kn-pink}\n",
        "\n",
        "<br>\n",
        "\n",
        "- MODEL 1 DATAFRAME OUTPUT\n",
        "\n",
        "\n",
        "## Forth, [run the model(s)]{.kn-pink}\n",
        "\n",
        "<br>\n",
        "\n",
        "And here's **Model 2**\n",
        "\n",
        "<br>\n"
      ],
      "id": "5c382fc5"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "model_2 = SIRModel(\n",
        "    n_initial_infections = model_2_params['n_initial_infections'],\n",
        "    grid_width = model_2_params['grid_width'],\n",
        "    grid_height = model_2_params['grid_height'],\n",
        "    N = model_2_params['N'],\n",
        "    infection_rate = model_2_params['infection_rate'],\n",
        "    recovery_time_range = model_2_params['recovery_time_range'],\n",
        "    max_agent_step_size = model_2_params['max_agent_step_size'],\n",
        ")\n",
        "\n",
        "for i in range(model_2_params['n_iterations']):\n",
        "    model_2.step()\n",
        "\n",
        "m2res = model_2.datacollector.get_model_vars_dataframe()"
      ],
      "id": "60d55858",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Forth, [run the model(s)]{.kn-pink}\n",
        "\n",
        "<br>\n",
        "\n",
        "- MODEL 2 DATAFRAME OUTPUT\n",
        "\n",
        "\n",
        "## Plot the results\n",
        "\n",
        "Recall: [Design patterns]{.kn-pink}\n",
        "\n",
        "<br>\n"
      ],
      "id": "9ab2c754"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "fig, ax = plt.subplots()\n",
        "ax.plot(m1res['Infected'], label=r'High transmissability, $\\beta$=0.3')\n",
        "ax.plot(m2res['Infected'], label=r'Low transmissability $\\beta$=0.15')\n",
        "plt.xlabel(\"\\nDiscrete Steps in Time\")\n",
        "plt.ylabel(\"Proportion Infected\\n\")\n",
        "plt.legend(loc='upper right', fontsize=10)\n",
        "plt.savefig('media/sir_compare_models_1-2.png')"
      ],
      "id": "1df34de0",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "<br>\n",
        "\n",
        ":::: {.columns}\n",
        "::: {.column width=\"25%\"}\n",
        "![](media/sir_compare){width=100%}\n",
        ":::\n",
        "\n",
        "::: {.column width=\"75%\"}\n",
        "$\\longleftarrow$<br>This is @fig-sir_compare from earlier in the lecture. Proportion of infected people in a population over time from two SIR simulations with different transmissability rates.\n",
        ":::\n",
        "::::\n",
        "\n",
        "<!-- (TEMPORARILY?) CUTTING THIS OUT; NO SPACE AND NOT PEDAGOGICALLY USEFUL ANYWAY -->\n",
        "<!-- _day-5-CUT-illustrative-models.qmd -->\n",
        "\n",
        "## Agent Interaction\n",
        "\n",
        "![Who interacted with whom?](media/anthony-delanoix-hzgs56Ze49s-unsplash.jpg){width=65% .shadow-img}\n",
        "\n",
        "\n",
        "## Agent Interaction \n",
        "\n",
        "We can iterate over the agents in the model and retrieve their interaction history. [Note that we can only do this because I built that data collection into the model! We can collect just about anything we want, but only if we set things up properly.]{.nord-light} Let's construct some agent **interaction networks**!\n",
        "\n",
        "<br>\n"
      ],
      "id": "2a11b1a0"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "interaction_graphs = {}\n",
        "interaction_graph_summaries = {}\n",
        "\n",
        "models = [model_1, model_2]\n",
        "for i, model in enumerate(models, start=1):\n",
        "    wel = []\n",
        "    for agent in model.schedule.agents:\n",
        "        for k, v in agent.interactions.items():\n",
        "            wel.append((int(agent.unique_id), k, v))\n",
        "    \n",
        "    G = nx.Graph()\n",
        "    G.add_weighted_edges_from(wel)  \n",
        "    interaction_graphs[f'M{i}'] = G\n",
        "    \n",
        "    avg_degree = round(sum(dict(G.degree()).values()) / float(G.number_of_nodes()), 2)\n",
        "    interaction_graph_summaries[f'M{i}'] = (G.number_of_nodes(), G.number_of_edges(), avg_degree)"
      ],
      "id": "a2713143",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Agent Interaction\n",
        "\n",
        "<br>\n"
      ],
      "id": "7df74254"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "interaction_graph_summaries = pd.DataFrame(interaction_graph_summaries).T\n",
        "interaction_graph_summaries.columns = ['No. Nodes', 'No. Edges', 'Avg. Degree']\n",
        "interaction_graph_summaries"
      ],
      "id": "1e8d58a3",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "from icsspy.utils import markdown_table\n",
        "md = markdown_table(interaction_graph_summaries, 'tables/_sir_1_interaction_graph_summaries.md')\n",
        "# print(md)"
      ],
      "id": "b6cc98a3",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "|   No. Nodes |   No. Edges |   Avg. Degree |\n",
        "|------------:|------------:|--------------:|\n",
        "|         100 |         984 |         19.68 |\n",
        "|         100 |         997 |         19.94 |\n",
        "\n",
        "<!-- won't load external table for some reason... -->\n",
        "\n",
        "<br>\n",
        "\n",
        ":::: {.columns}\n",
        "::: {.column width=\"65%\"}"
      ],
      "id": "10cd3fe0"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Initialize an empty graph\n",
        "G = interaction_graphs['M2']\n",
        "weights = [d['weight'] for u, v, d in G.edges(data=True)]\n",
        "\n",
        "plt.figure(figsize=(8, 6))\n",
        "sns.ecdfplot(weights)\n",
        "plt.xlabel('Interaction Weight')\n",
        "plt.ylabel('ECDF')\n",
        "plt.title('ECDF of Interaction Weights')\n",
        "plt.grid(True)\n",
        "plt.savefig('media/compare_agent_networks.png', dpi=300)"
      ],
      "id": "a73d89f9",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "# testing something... ignore this... nothing to see here...\n",
        "for agent in model_2.schedule.agents:\n",
        "    G.add_node(agent.unique_id)  # Add agent as a node\n",
        "    for interacted_agent, count in agent.interactions.items():\n",
        "        if G.has_edge(agent.unique_id, interacted_agent):\n",
        "            G[agent.unique_id][interacted_agent]['weight'] += count\n",
        "        else:\n",
        "            G.add_edge(agent.unique_id, interacted_agent, weight=count)"
      ],
      "id": "61161b17",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        ":::\n",
        "\n",
        "::: {.column width=\"35%\"}\n",
        "![Model 2 edge weight ECDF.](media/compare_agent_networks.png){width=\"75%\" #fig-compare_agent_networks}\n",
        ":::\n",
        "::::\n",
        "\n",
        "# [[deeper dives with]{.small-text .light-against-image}<br>BatchRunner]{.kn-pink} {background-image=media/jeremy-bishop-5MvL55-rSvI-unsplash.jpg}\n",
        "\n",
        "<!-- Photo by <a href=\"https://unsplash.com/@sebaspenalambarri?utm_content=creditCopyText&utm_medium=referral&utm_source=unsplash\">Sebastian Pena Lambarri</a> on <a href=\"https://unsplash.com/photos/two-people-scuba-diving-underwater-7i5HMCGupVw?utm_content=creditCopyText&utm_medium=referral&utm_source=unsplash\">Unsplash</a>\n",
        "   -->\n",
        "\n",
        "\n",
        "## Sensitivity Analysis, Parameter Sweeps, Experiments\n",
        "\n",
        "`BatchRunner` let's us easily go beyond single simulation runs, [which is essential]{.kn-pink}! First, define a dict containing parameter valus.\n"
      ],
      "id": "5571f50d"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "params = {\n",
        "    \"N\": 100,  \n",
        "    \"grid_height\": 40,\n",
        "    \"grid_width\": 40,\n",
        "    \"infection_rate\": [0.1, 0.2, 0.3, 0.4, 0.5, 0.55, 0.6, 0.7, 0.8, 0.9],\n",
        "    \"recovery_time_range\": [(14,24)],\n",
        "    \"max_agent_step_size\": [4, 8, 12, 16], \n",
        "}"
      ],
      "id": "3ed7f0d0",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Then run your model using the `batch_run()` function.\n",
        "\n",
        "```python\n",
        "results = mesa.batch_run(\n",
        "    SIRModel,  # Your model class\n",
        "    parameters=params,\n",
        "    iterations=10,  # Number of iterations per parameter combination\n",
        "    max_steps=100,  # Number of steps in each simulation\n",
        "    number_processes=1,  # Use N CPU cores for parallel processing\n",
        "    data_collection_period=1,  # Collect data at every step\n",
        "    display_progress=True,  # Show progress bar during execution\n",
        ")\n",
        "\n",
        "results_df = pd.DataFrame(results)\n",
        "```\n"
      ],
      "id": "73e34387"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "# \n",
        "# if error on laptop, it's multi-processing in a notebook\n",
        "# change number_processes to 1\n",
        "# \n",
        "results = mesa.batch_run(\n",
        "    SIRModel,  \n",
        "    parameters=params,\n",
        "    iterations=10,  \n",
        "    max_steps=100,  \n",
        "    number_processes=1,  \n",
        "    data_collection_period=1,  \n",
        "    display_progress=True,  \n",
        ")\n",
        "\n",
        "results_df = pd.DataFrame(results)"
      ],
      "id": "80e0a76c",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "##\n"
      ],
      "id": "a3d941f5"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "from icsspy.utils import markdown_table\n",
        "md = markdown_table(results_df.head(), 'tables/_sir_batch_results_df.md')\n",
        "print(md)"
      ],
      "id": "6cdda989",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "```python\n",
        "results_df.head()\n",
        "```\n",
        "\n",
        "|   RunId |   iteration |   Step |   N |   grid_height |   grid_width |   infection_rate | recovery_time_range   |   max_agent_step_size |   Infected |   AgentID | State   |   Infection_Duration |\n",
        "|--------:|------------:|-------:|----:|--------------:|-------------:|-----------------:|:----------------------|----------------------:|-----------:|----------:|:--------|---------------------:|\n",
        "|       0 |           0 |      0 | 100 |            40 |           40 |             0.45 | (14, 24)              |                     2 |       0.01 |         0 | S       |                    0 |\n",
        "|       0 |           0 |      0 | 100 |            40 |           40 |             0.45 | (14, 24)              |                     2 |       0.01 |         1 | S       |                    0 |\n",
        "|       0 |           0 |      0 | 100 |            40 |           40 |             0.45 | (14, 24)              |                     2 |       0.01 |         2 | S       |                    0 |\n",
        "|       0 |           0 |      0 | 100 |            40 |           40 |             0.45 | (14, 24)              |                     2 |       0.01 |         3 | S       |                    0 |\n",
        "|       0 |           0 |      0 | 100 |            40 |           40 |             0.45 | (14, 24)              |                     2 |       0.01 |         4 | S       |                    0 |\n"
      ],
      "id": "c5cbc739"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "from icsspy.utils import markdown_table\n",
        "md = markdown_table(results_df.tail(), 'tables/_sir_batch_results_df_tail.md')\n",
        "print(md)"
      ],
      "id": "d78b93a5",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "```python\n",
        "results_df.tail()\n",
        "```\n",
        "\n",
        "|   RunId |   iteration |   Step |   N |   grid_height |   grid_width |   infection_rate | recovery_time_range   |   max_agent_step_size |   Infected |   AgentID | State   |   Infection_Duration |\n",
        "|--------:|------------:|-------:|----:|--------------:|-------------:|-----------------:|:----------------------|----------------------:|-----------:|----------:|:--------|---------------------:|\n",
        "|     399 |           9 |      1 | 100 |            40 |           40 |              0.9 | (14, 24)              |                    16 |       0.02 |        95 | S       |                    0 |\n",
        "|     399 |           9 |      1 | 100 |            40 |           40 |              0.9 | (14, 24)              |                    16 |       0.02 |        79 | S       |                    0 |\n",
        "|     399 |           9 |      1 | 100 |            40 |           40 |              0.9 | (14, 24)              |                    16 |       0.02 |         9 | S       |                    0 |\n",
        "|     399 |           9 |      1 | 100 |            40 |           40 |              0.9 | (14, 24)              |                    16 |       0.02 |        62 | S       |                    0 |\n",
        "|     399 |           9 |      1 | 100 |            40 |           40 |              0.9 | (14, 24)              |                    16 |       0.02 |        85 | S       |                    0 |\n",
        "\n",
        "\n",
        "[Be selective about the data you collect during a batch run. I collected everything (including things that don't vary) here for pedagogical reasons only! Another run I did with this model produced a 4GB text file with only 6 variables. So, yeah.]{.nord-footer}\n",
        "\n",
        "## Batch Results\n",
        "\n",
        "<br>\n"
      ],
      "id": "9835fa24"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "plt.figure(figsize=(12, 8))\n",
        "for rate in params['infection_rate']:\n",
        "    subset = results_df[(results_df['infection_rate'] == rate) & (results_df['Step'] > 0)]\n",
        "    mean_infected = subset.groupby('Step')['Infected'].mean()\n",
        "    plt.plot(mean_infected.index, mean_infected.values, label=f\"Infection Rate: {rate}\")\n",
        "\n",
        "plt.title('Time Series of Proportion Infected Across Different Infection Rates')\n",
        "plt.xlabel('Time Step')\n",
        "plt.ylabel('Proportion Infected')\n",
        "plt.legend(loc='best')\n",
        "plt.savefig(\"media/Time Series of Proportion Infected Across Different Infection Rates.png\", dpi=300)"
      ],
      "id": "e446dc41",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "##\n",
        "\n",
        ":::: {.columns}\n",
        "::: {.column width=\"45%\"}"
      ],
      "id": "d79c3078"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "final_infected_by_rate = results_df.groupby('infection_rate')['Infected'].last()\n",
        "\n",
        "plt.figure(figsize=(10, 6))\n",
        "plt.plot(final_infected_by_rate.index, final_infected_by_rate.values, marker='o')\n",
        "plt.title('Final Proportion Infected vs. Infection Rate')\n",
        "plt.xlabel('Infection Rate')\n",
        "plt.ylabel('Final Proportion Infected')\n",
        "plt.savefig('media/batched_sit_final_infections.png', dpi=300)"
      ],
      "id": "945c9a64",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        ":::\n",
        "\n",
        "::: {.column width=\"10%\"}\n",
        ":::\n",
        "\n",
        "::: {.column width=\"45%\"}\n",
        "![](media/media/batched_sit_final_infections.png){width=\"100%\"}\n",
        ":::\n",
        "::::\n"
      ],
      "id": "d590e342"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "plt.figure(figsize=(12, 8))\n",
        "sns.boxplot(x='infection_rate', y='Infection_Duration', data=recovered_agents)\n",
        "plt.title('Boxplot of Infection Durations for Different Infection Rates')\n",
        "plt.xlabel('Infection Rate')\n",
        "plt.ylabel('Infection Duration (Steps)')\n",
        "plt.show()"
      ],
      "id": "0188de0f",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "heatmap_data = results_df.pivot_table(index='max_agent_step_size', columns='infection_rate', values='Infected', aggfunc='last')\n",
        "\n",
        "plt.figure(figsize=(10, 8))\n",
        "sns.heatmap(heatmap_data, annot=True, cmap='viridis')\n",
        "plt.title('Heatmap of Final Proportion Infected vs. Infection Rate and Agent Step Size')\n",
        "plt.xlabel('Infection Rate')\n",
        "plt.ylabel('Max Agent Step Size')\n",
        "plt.show()"
      ],
      "id": "41e2cd54",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "fig, axs = plt.subplots(1, 2, figsize=(24, 12))\n",
        "\n",
        "# Agent 7\n",
        "x7, y7 = zip(*agent_7.pos_history)\n",
        "axs[0].plot(x7, y7, label=f\"Agent {agent_7.unique_id} (Step size: {agent_7.max_agent_step_size})\", color='blue')\n",
        "axs[0].set_title(f\"Agent {agent_7.unique_id} (Step size: {agent_7.max_agent_step_size})\")\n",
        "axs[0].set_xlabel(\"X Position\")\n",
        "axs[0].set_ylabel(\"Y Position\")\n",
        "axs[0].grid(True, which='both', linestyle='--')\n",
        "\n",
        "# Larger step agent\n",
        "x_large, y_large = zip(*larger_step_agent.pos_history)\n",
        "axs[1].plot(x_large, y_large, label=f\"Agent {larger_step_agent.unique_id} (Step size: {larger_step_agent.max_agent_step_size})\", color='red')\n",
        "axs[1].set_title(f\"Agent {larger_step_agent.unique_id} (Step size: {larger_step_agent.max_agent_step_size})\")\n",
        "axs[1].set_xlabel(\"X Position\")\n",
        "axs[1].set_ylabel(\"Y Position\")\n",
        "axs[1].grid(True, which='both', linestyle='--')\n",
        "\n",
        "plt.tight_layout()\n",
        "plt.savefig('media/compare_agent_step_sizes.png', dpi=300)\n",
        "plt.show()"
      ],
      "id": "3dfc3b00",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Extract the edge weights\n",
        "weights = [d['weight'] for u, v, d in G.edges(data=True)]\n",
        "\n",
        "plt.figure(figsize=(8, 6))\n",
        "sns.ecdfplot(weights)\n",
        "plt.xlabel('Interaction Weight')\n",
        "plt.ylabel('ECDF')\n",
        "plt.title('ECDF of Interaction Weights')\n",
        "plt.grid(True)\n",
        "plt.savefig('media/compare_agent_networks.png', dpi=300)\n",
        "plt.show()"
      ],
      "id": "d6253baf",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Comparing Batch Runs\n"
      ],
      "id": "ab3be43d"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Compute mean and variance of infection durations by infection rate\n",
        "mean_duration = results_df.groupby('infection_rate')['Infection_Duration'].mean()\n",
        "var_duration = results_df.groupby('infection_rate')['Infection_Duration'].var()\n",
        "\n",
        "# Plot the mean and variance\n",
        "plt.figure(figsize=(12, 6))\n",
        "plt.plot(mean_duration.index, mean_duration.values, label='Mean Infection Duration', marker='o')\n",
        "plt.fill_between(mean_duration.index, mean_duration.values - np.sqrt(var_duration.values),\n",
        "                 mean_duration.values + np.sqrt(var_duration.values), alpha=0.3)\n",
        "plt.title('Mean and Variance of Infection Duration by Infection Rate')\n",
        "plt.xlabel('Infection Rate')\n",
        "plt.ylabel('Infection Duration (Steps)')\n",
        "plt.legend(loc='best')\n",
        "plt.show()"
      ],
      "id": "b7c6a291",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "plt.figure(figsize=(12, 8))\n",
        "sns.boxplot(x='infection_rate', y='Infected', data=results_df[results_df['Step'] == results_df['Step'].max()])\n",
        "plt.title('Boxplot of Final Proportion Infected Across Infection Rates')\n",
        "plt.xlabel('Infection Rate')\n",
        "plt.ylabel('Final Proportion Infected')\n",
        "plt.show()"
      ],
      "id": "b059c57b",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "heatmap_data = results_df.pivot_table(index='max_agent_step_size', columns='infection_rate', values='Infected', aggfunc='mean')\n",
        "\n",
        "plt.figure(figsize=(10, 8))\n",
        "sns.heatmap(heatmap_data, annot=True, cmap='viridis')\n",
        "plt.title('Heatmap of Final Proportion Infected by Infection Rate and Step Size')\n",
        "plt.xlabel('Infection Rate')\n",
        "plt.ylabel('Max Agent Step Size')\n",
        "plt.show()"
      ],
      "id": "b05f8ee1",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "plt.figure(figsize=(12, 8))\n",
        "for rate in params['infection_rate']:\n",
        "    subset = recovered_agents[recovered_agents['infection_rate'] == rate]\n",
        "    sns.ecdfplot(subset['Infection_Duration'], label=f\"Infection Rate: {rate}\")\n",
        "\n",
        "plt.title('CDF of Infection Durations Across Different Infection Rates')\n",
        "plt.xlabel('Infection Duration (Steps)')\n",
        "plt.ylabel('Cumulative Frequency')\n",
        "plt.legend(loc='best')\n",
        "plt.show()"
      ],
      "id": "17b9458f",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "sns.pairplot(results_df, hue='infection_rate', vars=['Infection_Duration', 'Infected'])\n",
        "plt.suptitle('Pairwise Scatter Plot of Outcomes by Infection Rate')\n",
        "plt.show()"
      ],
      "id": "e2418d82",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "summary_table = results_df.groupby('infection_rate').agg({\n",
        "    'Infection_Duration': ['mean', 'median', 'var', 'min', 'max'],\n",
        "    'Infected': ['mean', 'median', 'var', 'min', 'max']\n",
        "})\n",
        "\n",
        "print(summary_table)"
      ],
      "id": "5a847274",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "plt.figure(figsize=(12, 8))\n",
        "for iteration in results_df['iteration'].unique():\n",
        "    subset = results_df[(results_df['iteration'] == iteration)]\n",
        "    plt.plot(subset['Step'], subset['Infected'], alpha=0.5, label=f\"Run {iteration}\")\n",
        "\n",
        "plt.title('Overlay of Proportion Infected Across Multiple Runs')\n",
        "plt.xlabel('Time Step')\n",
        "plt.ylabel('Proportion Infected')\n",
        "plt.legend(loc='best', fontsize=8)\n",
        "plt.show()"
      ],
      "id": "28868a9e",
      "execution_count": null,
      "outputs": []
    }
  ],
  "metadata": {
    "kernelspec": {
      "display_name": "Python 3",
      "language": "python",
      "name": "python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}
