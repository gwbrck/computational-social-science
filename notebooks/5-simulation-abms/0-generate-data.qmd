---
title: "Social Simulation & Agent-based Modelling"
description: "This is the first notebook in a tutorial series on social simulation and agent-based modelling for Introduction to Computational Social Science with Python in the GESIS 2024 Fall Seminar in Computational Social Science."
author: "John McLevey"
date: "{{< date >}}"
categories:
---

```{python}
import numpy as np
import pandas as pd
from graph_tool.all import *
import seaborn as sns
import matplotlib.pyplot as plt
import matplotlib.ticker as ticker

from icsspy.paths import enron
from icsspy import set_style

set_style()
plt.rcParams['text.usetex'] = True
```

```{python}
enron_email_network = str(enron / 'enron_graph.gt')
g = load_graph(enron_email_network)
print(g)
```

## Simulate from the Generative Model

Once we have a generative model of a network, we can use our model to generate synthetic networks based on the observed network. We will use this generative model to create datasets that can be used in our ABMs. First, we'll fit a simple one-level blockmodel using `graph-tool` and then use the `generate_sbm()` function to simulate networks from this model.

```{python}
state = minimize_blockmodel_dl(g)
synthetic_g = generate_sbm(state.b.a, state.get_matrix(), directed=g.is_directed())
g, synthetic_g
```

```{python}
synthetic_g = extract_largest_component(synthetic_g, directed=True)
synthetic_g
```

- We can plot these two objects and see how similar they are

Now we can process this network to get the probabilities of connections for specific edges. First we extract the block membership for each node in the simulated network.

```{python}
blocks = state.get_blocks()
```

We'll also extract the block matrix containing **expected counts** and calculate the size of each block (i.e., the number of nodes in the block, obtained using the `bincount` function).

```{python}
block_matrix = state.get_matrix()
block_counts = np.bincount(blocks.a)
```

Next, we'll create a new property map to store edge weights and populate it with connection probabilities.

```{python}
edge_weights = g.new_edge_property("double")

for e in g.edges():
    i, j = int(e.source()), int(e.target())
    k, l = blocks[i], blocks[j]
    # calculate the probability of connection between nodes i and j
    if block_counts[k] > 0 and block_counts[l] > 0:
        prob = block_matrix[k, l] / (block_counts[k] * block_counts[l])
    else:
        prob = 0  # in case the block size is zero
    edge_weights[e] = prob

g.ep["weight"] = edge_weights
```

Let's plot these connection probabilities to see what they look like overall.

```{python}
g.list_properties()
```

```{python}
title_string = "EDCF of edge weights (probabilities)\n" + r"in the \textbf{simulated} communication network" + "\n"

sns.ecdfplot(g.ep.weight.a)
plt.xlabel("\n" + r"$p(edge)$")
plt.ylabel("Proportion of edges\n")
plt.title(title_string, loc="left", fontsize=12)
plt.xlim(0,1)

plt.gca().set_xlim(left=-0.05, right=1.05)  # make some space
plt.gca().set_ylim(bottom=-0.05, top=1.05)  # make some space
plt.savefig('output/sim_net_pedge_ecdf.png', dpi=300)
```

And now let's export this simulated network to a weighted edgelist with three columns: `i`, `j`, and `p(edge)` indicating that our weight is the probability of $i$ connecting to $j$.

```{python}
stp = []
for e in synthetic_g.edges():
    stp.append((int(e.source()), int(e.target()), g.ep['weight'][e]))
```

We can add this data to a Pandas dataframe.

```{python}
stp = pd.DataFrame(stp)
stp.columns = ['i', 'j', 'p(edge)']
stp.head()
```

```{python}
def df_to_md(df, filepath):
    md = df.to_markdown(index=False)
    with open(filepath, 'w') as f:
        f.write(md)
df_to_md(stp.sample(10), 'output/sim_net_wel_df.md')
```


Not write it to disk for our work in `ndlib`.

```{python}
stp.to_csv('output/simulated_network.csv', index=False)
```

```{python}
def draw_state(state, g, pos, filename=None):
    state.draw(
        pos=pos,
        edge_gradient=[],
        edge_color="#33333330",
        output_size=(1200, 1200),
        bg_color=[1, 1, 1, 1],
        output=filename
)

pos_refined = sfdp_layout(g, groups=state.b, gamma=.08)

draw_state(state=state, g=g, pos=pos_refined, filename='output/simulated_g.png')
```
